/*
Task №3:
Напишите программу вычисления функции Аккермана с помощью рекурсии. Даны два неотрицательных числа m и n.
m = 2, n = 3 -> A(m,n) = 9
m = 3, n = 2 -> A(m,n) = 29



//Функция Акермана:

// Пояснение сокращений в виду отсуствия данных букв в программе С#:
// lambda - L (Она же - построенная Аккерманом функция)
// alpha - A (Она же - Альфа)

//    L(a,b,0) = a + b
//    L(a,0,n + 1) = A(a,n)
//    L(a,b + 1,n + 1) = L(A,L(a,b,n + 1),n)

// Здесь так же A(a, n) ещё одна функция, зажающая начальное значение, а * 0, a(в степени 0),....;

//           0 при n = 0
// A(a, n) = 1 при n = 1
//           a при n > 1 

// Определение Петер:
// Более простое построение в котором функция имеет только два парметра, вспомогательная функция А не используется.

// Предыдущее пояслнения не соотнясятся с тем что ниже!

// A(0, m)          =   m + 1
// A(n + 1,0)       =   A(n,1)
// A(n + 1,m + 1)   =   A(n,A(n + 1,m))

// Псевдо-код функции Акермана:
//          n + 1                      m = 0 
// A(m,n) = A(m - 1, 1)                m > 0 and n = 0
//          A(m - 1, A(m, n - 1 ))     m > 0 and n > 0



// ---Вариант №1---
// Переполнение стека при значении больше (4, 0) и (3,5) 

int Ackermann(int num1, int num2)
{
    if(num1 == 0)
    {
        return num2 + 1;
    }
    else if(num2 == 0)
    {
        return Ackermann(num1 - 1, 1); 
    }
    else
    {
        return Ackermann(num1 - 1, Ackermann(num1, num2-1));
    }
 
}

Console.WriteLine(Ackermann(3,5));

// ---Вариант №2---
// Аналогично переполнение стека при значении больше (4, 0) и (3,5) и (5,3)



int Ackermann(int num1, int num2)
{
    if(num1 == 0)
    {
        return num2 + 1;
    }
    else if(num1 > 0 && num2 == 0)
    {
        return Ackermann(num1 - 1, 1); 
    }
    else
    {
        return Ackermann(num1 - 1, Ackermann(num1, num2-1));
    }
   
}

Console.WriteLine(Ackermann(4,0));


*/
// ---Вариант №3---
// При больших значениях n и m может возникнуть переполнение стека, 
// так как функция Аккермана является дважды рекурсивной:
// один из аргументов функции есть та же рекурсивная функция.


int Ackermann(int num1, int num2)
{
    if(num1 == 0)
    {
        return num2 + 1;
    }
    else if(num1 > 0 && num2 == 0)
    {
        return Ackermann(num1 - 1, 1); 
    }
    else if(num1 > 0 && num2 > 0)
    {
        return Ackermann(num1 - 1, Ackermann(num1, num2-1));
    }
    else
    {
        return num2 + 1;
    }
}

Console.WriteLine(Ackermann(5,3));



